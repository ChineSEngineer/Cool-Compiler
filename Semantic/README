README file for Programming Assignment 4 (C++ edition)
======================================================

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	Do not modify any other file.

Instructions
------------

	To compile your semantic analyzer program type:

	% make

	This produces an executable named "semant" which is standalone
	phase of the Cool compiler. The semantic analyzer executable
	accepts as input the output of the parser phase, so in order 
	to test it, you'll need to copy a lexer and a parser into the
	directory: either your own lexer and parser from the previous
	assignments, or the lexer and parser from the reference
	implementation of the compiler.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

    If you think your semantic checker is correct and behaves like
    the one we wrote, you can try it out by replacing the semantic
    checker in the reference compiler with your own lexer. Just copy
    your compiled semantic binary from this assignment into the
    directory where the reference compiler is.

    To submit your solution, run:

    % make zip

    Check the resulting zip file to make sure it contains everything
    it should. Then submit it on Gradescope.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

1. Explain design decisions, explain why your code is correct, and
	why your test cases are adequate.

Basically, there are 3 steps in my semantic analysis.

1. Iterate all the classes, record the class name and its parent class. Based on the relationship of inheritance, dfs all the classes. We can check if there exist circles in the inheritance graph. It there exist some inheritance relationships which are not permited. 

2. Iterate AST tree in the dfs other. Meanwhile, we keep two symbol tables while we are iterating. One is used to record attributes' names, the other is used to record methods' names. For the attribute symbol table, I'll call enterscope() in the class, method, block, case-branch nodes. For the method symbol table, I'll call enterscope() in the class nodes. In every scope call addid when it is necessary. Also, I will save the symbol table's current location for every node in the AST tree. I'll retrieve the location in the later steps. After this step, I can gurantee that all attributes, methods and local variables are registered, all declared types are valid types and there is no multiple definitions or invalid override definitions in any classes.

3. Iterate AST tree in the dfs again. Based on the semantic rules of cool language. Inferred the type for every expression, method's return type. Check if types are valid when dispatching the methods, assigning a varaible or attribute. Remember that we have saved the context for every node in the step2.

The first step is for inheritance relationship check.
The second step is for type&name declaration check.
The third step is for compile-time type check.
